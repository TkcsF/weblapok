<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Szénhidrogén keresztelő</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Rubik:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #2c3e50;
      --accent: #16a085;
      --light: #ecf0f1;
      --dark: #34495e;
      --warning: #f39c12;
      --font-sans: 'Rubik', sans-serif;
      --font-mono: 'Roboto Mono', monospace;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--light); color: var(--primary); font-family: var(--font-sans); }
    header { background: var(--primary); color: var(--light); padding: 1rem; text-align: center; }
    main { max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
    .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 1rem; }
    label { font-weight: 500; }
    select, input[type=text] { flex: 1; padding: 0.5rem; border: 1px solid var(--dark); border-radius: 4px; font-family: var(--font-mono); }
    button { padding: 0.5rem 1rem; background: var(--accent); color: var(--light); border: none; border-radius: 4px; cursor: pointer; font-weight: 500; }
    button:disabled { background: #bdc3c7; cursor: not-allowed; }
    button#hintBtn { background: var(--warning); }
    button#hintBtn:disabled { background: #bdc3c7; }
    canvas { display: block; margin: 0 auto 1rem; background: #fff; border: 2px solid var(--dark); border-radius: 8px; width: 100%; max-width: 700px; height: auto; }
    #result { font-size: 1.1rem; padding: 0.5rem; border-radius: 4px; margin-bottom: 1rem; }
    #result.success { background: #dff0d8; color: #3c763d; }
    #result.error { background: #f2dede; color: #a94442; }
    #hint { background: #fff3cd; color: #856404; padding: 1rem; border: 1px solid var(--warning); border-radius: 8px; margin-bottom: 1rem; display: none; }
    #hint h3 { margin-top: 0; }
    #hint ul { margin: 0.5rem 0; padding-left: 1.5rem; }
    #hint .answer { font-family: var(--font-mono); font-weight: 700; font-size: 1.1rem; margin-top: 0.5rem; }
    #stats { background: #fff; padding: 1rem; border: 1px solid var(--dark); border-radius: 8px; }
    #stats div { display: flex; justify-content: space-between; padding: 0.25rem 0; font-family: var(--font-mono); }
    footer { text-align: center; margin: 2rem 0; color: var(--dark); }
  </style>
</head>
<body>
  <header>
    <h1>Szénhidrogén keresztelő</h1>
  </header>
  <main>
    <div class="controls">
      <label for="difficulty">Nehézség:</label>
      <select id="difficulty">
        <option value="1">1: Nyílt lánc, elágazás nélkül</option>
        <option value="2">2: Nyílt lánc, 1 elágazás</option>
        <option value="3">3: Nyílt lánc, több elág.</option>
        <option value="4">4: Nyílt lánc/gyűrű</option>
      </select>
      <button id="newBtn">Új molekula</button>
    </div>
    <canvas id="molecule" width="700" height="300"></canvas>
    <div class="controls">
      <label for="nameInput">Molekula neve:</label>
      <input type="text" id="nameInput" placeholder="pl. 2,5-dimetil-okt-3-én">
      <button id="hintBtn">Segítség</button>
      <button id="checkBtn">Ellenőriz</button>
    </div>
    <div id="hint" aria-live="polite"></div>
    <div id="result" aria-live="polite"></div>
    <section id="stats">
      <h2>Statisztika</h2>
      <div>1-es: <span id="correct1">0</span>✔ / <span id="wrong1">0</span>✘</div>
      <div>2-es: <span id="correct2">0</span>✔ / <span id="wrong2">0</span>✘</div>
      <div>3-as: <span id="correct3">0</span>✔ / <span id="wrong3">0</span>✘</div>
      <div>4-es: <span id="correct4">0</span>✔ / <span id="wrong4">0</span>✘</div>
    </section>
  </main>
  <footer>© 2025 Szénhidrogén Névellenőrző</footer>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const prefixes = ["", "met", "et", "prop", "but", "pent", "hex", "hept", "okt", "non", "dek"];
      const maxL = 10;
      let currentName = '';
      let currentExplanation = '';
      let hasMolecule = false;
      const stats = {1:{correct:0,wrong:0},2:{correct:0,wrong:0},3:{correct:0,wrong:0},4:{correct:0,wrong:0}};

      const newBtn = document.getElementById('newBtn');
      const checkBtn = document.getElementById('checkBtn');
      const hintBtn = document.getElementById('hintBtn');
      const nameInput = document.getElementById('nameInput');
      const resultDiv = document.getElementById('result');
      const hintDiv = document.getElementById('hint');

      function normalize(str) {
        return str.normalize('NFD')
                  .replace(/[\u0300-\u036f]/g, '')
                  .replace(/\s+/g, '')
                  .toLowerCase();
      }

      function updateStatsUI(level) {
        document.getElementById(`correct${level}`).textContent = stats[level].correct;
        document.getElementById(`wrong${level}`).textContent = stats[level].wrong;
      }

      function drawMolecule() {
        const canvas = document.getElementById('molecule');
        const ctx = canvas.getContext('2d');
        
        // Beállítjuk a canvas belső felbontását
        const displayWidth = canvas.offsetWidth;
        const displayHeight = Math.round(displayWidth * 300 / 700);
        
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
        }
        
        const margin = canvas.width * 0.03;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const diff = +document.getElementById('difficulty').value;
        let isCyclic = false;
        let L;
        if (diff === 4 && Math.random() < 0.5) {
          isCyclic = true;
          L = Math.floor(Math.random() * (maxL - 4)) + 5;
        } else {
          L = Math.floor(Math.random() * (maxL - 2)) + 3;
        }

        const bondPositions = Array.from({length: L-1}, (_, i) => i+1);
        const dbCount = diff <= 2 ? (Math.random()<0.5?1:0) : Math.floor(Math.random()*Math.min(2, L-1))+1;
        const dbPos = [];
        for (let i = 0; i < dbCount; i++) {
          const idx = Math.floor(Math.random() * bondPositions.length);
          dbPos.push(bondPositions.splice(idx, 1)[0]);
        }

        const branchCount = diff === 2 ? 1 : (diff >= 3 ? Math.floor(Math.random() * 2) + 1 : 0);
        const sitePositions = Array.from({length: L}, (_, i) => i+1).filter(x => x>1 && x<L);
        const branches = [];
        for (let i = 0; i < branchCount; i++) {
          if (!sitePositions.length) break;
          
          let pos, len, idx;
          let isValid = false;
          let attempts = 0;

          while (!isValid && sitePositions.length > 0 && attempts < 50) {
            idx = Math.floor(Math.random() * sitePositions.length);
            pos = sitePositions[idx];
            len = Math.floor(Math.random() * Math.min(3, L-2)) + 1;

            const isInvalidEthyl = (len === 2 && pos === L - 1);
            const isInvalidPropyl = (len === 3 && (pos === L - 1 || pos === L - 2));

            if (!isInvalidEthyl && !isInvalidPropyl) {
              isValid = true;
              sitePositions.splice(idx, 1);
              branches.push({pos, len});
            }
            attempts++;
          }
        }

        const forwardDb = [...dbPos].sort((a,b)=>a-b);
        const forwardSub = branches.map(b=>b.pos).sort((a,b)=>a-b);
        const revDb = dbPos.map(p=>L-p).sort((a,b)=>a-b);
        const revSub = branches.map(b=>L-b.pos+1).sort((a,b)=>a-b);
        function lexCompare(a, b) {
          for (let i=0; i<Math.min(a.length, b.length); i++) {
            if (a[i] < b[i]) return -1;
            if (a[i] > b[i]) return 1;
          }
          return a.length - b.length;
        }
        if (lexCompare([...revDb, ...revSub], [...forwardDb, ...forwardSub]) < 0) {
          dbPos.splice(0, dbPos.length, ...revDb);
          branches.forEach(b => b.pos = L - b.pos + 1);
        } else {
          dbPos.splice(0, dbPos.length, ...forwardDb);
        }

        // Magyarázat generálása
        const explanation = [];
        explanation.push(`<h3>Elemzés:</h3>`);
        explanation.push(`<ul>`);
        explanation.push(`<li><strong>Főlánc:</strong> ${L} szénatom ${isCyclic ? '(gyűrű)' : '(nyílt lánc)'} → <code>${isCyclic ? 'ciklo' : ''}${prefixes[L]}</code></li>`);
        
        if (branches.length > 0) {
          explanation.push(`<li><strong>Elágazások (abc sorrendben):</strong></li>`);
          explanation.push(`<ul>`);
          const subGroups = {};
          branches.forEach(b => { subGroups[b.len] = subGroups[b.len]||[]; subGroups[b.len].push(b.pos); });
          Object.keys(subGroups)
            .sort((a, b) => prefixes[a].localeCompare(prefixes[b], 'hu'))
            .forEach(lenKey => {
              const poses = subGroups[lenKey].sort((a,b)=>a-b);
              const cnt = poses.length;
              const mult = cnt===2?'di':cnt===3?'tri':cnt===4?'tetra':'';
              explanation.push(`<li>${cnt} db ${prefixes[lenKey]}il csoport a(z) ${poses.join(', ')}. szénatomnál → <code>${poses.join(',')}-${mult}${prefixes[lenKey]}il</code></li>`);
            });
          explanation.push(`</ul>`);
        }

        if (dbPos.length > 0) {
          const multi = dbPos.length===2?'dién':dbPos.length===3?'trién':'én';
          explanation.push(`<li><strong>Kettős kötés(ek):</strong> ${dbPos.length} db, a(z) ${dbPos.join(', ')}. szénatomnál kezdődik → <code>${dbPos.join(',')}-${multi}</code></li>`);
        } else {
          explanation.push(`<li><strong>Telített:</strong> Nincs kettős kötés → <code>án</code> végződés</li>`);
        }

        explanation.push(`</ul>`);
        explanation.push(`<h3>Névépítés:</h3>`);
        explanation.push(`<p><strong>Séma:</strong> [elágazások]-[főlánc]-[kettőskötés-pozíciók]-[végződés]</p>`);

        const subGroups = {};
        branches.forEach(b => { subGroups[b.len] = subGroups[b.len]||[]; subGroups[b.len].push(b.pos); });
        const parts = [];
        const nameParts = [];
        Object.keys(subGroups)
          .sort((a, b) => prefixes[a].localeCompare(prefixes[b], 'hu'))
          .forEach(lenKey => {
            const poses = subGroups[lenKey].sort((a,b)=>a-b);
            const cnt = poses.length;
            const mult = cnt===2?'di':cnt===3?'tri':cnt===4?'tetra':'';
            const partName = `${poses.join(',')}-${mult}${prefixes[lenKey]}il`;
            parts.push(partName);
            nameParts.push(`<span class="name-part">${partName}</span>`);
          });
        const root = isCyclic ? `ciklo${prefixes[L]}` : prefixes[L];
        let suffix;
        if (dbPos.length > 1) {
          const multi = dbPos.length===2?'dién':dbPos.length===3?'trién':'én';
          suffix = `${root}-${dbPos.join(',')}-${multi}`;
          nameParts.push(`<span class="name-part">${root}</span>`);
          nameParts.push(`<span class="name-part">${dbPos.join(',')}-${multi}</span>`);
        } else if (dbPos.length === 1) {
          suffix = `${root}-${dbPos[0]}-én`;
          nameParts.push(`<span class="name-part">${root}</span>`);
          nameParts.push(`<span class="name-part">${dbPos[0]}-én</span>`);
        } else {
          suffix = `${root}án`;
          nameParts.push(`<span class="name-part">${root}án</span>`);
        }
        parts.push(suffix);
        currentName = parts.join('-');
        currentExplanation = explanation.join('') + `<div class="name-parts">${nameParts.join('')}</div>`;

        const pts = [];
        const branchLen = canvas.width * 0.045;
        const nodeRadius = Math.max(4, canvas.width * 0.007);
        let scaleFactor = 1;
        
        if (isCyclic) {
          const cx = canvas.width/2, cy = canvas.height/2;
          const r = (Math.min(canvas.width, canvas.height) - 2*margin)/2;
          
          // Elforgatás úgy, hogy az alsó kötés vízszintes legyen
          // Kivétel: 8 csúcsú gyűrűnél csúcs legyen alul
          let angleOffset;
          if (L === 8) {
            angleOffset = -Math.PI/2; // Csúcs alul
          } else {
            angleOffset = -Math.PI/2 + Math.PI/L; // Kötés alul (vízszintes)
          }
          
          for (let i = 0; i < L; i++) {
            pts.push({ 
              x: cx + r*Math.cos(2*Math.PI*i/L + angleOffset), 
              y: cy + r*Math.sin(2*Math.PI*i/L + angleOffset) 
            });
          }
          
          // Ellenőrizzük, hogy az elágazások kilógnak-e
          if (branches.length > 0) {
            let maxExtent = 0;
            let angleOffset;
            if (L === 8) {
              angleOffset = -Math.PI/2;
            } else {
              angleOffset = -Math.PI/2 + Math.PI/L;
            }
            
            branches.forEach(b => {
              const p = pts[b.pos-1];
              const ang = -Math.PI/2; // Mindig felfelé
              
              let endX = p.x, endY = p.y;
              
              for (let j = 0; j < b.len; j++) {
                endX = endX + Math.cos(ang)*branchLen;
                endY = endY + Math.sin(ang)*branchLen;
              }
              
              // Távolságok a széltől
              const marginNeeded = nodeRadius + 2;
              const leftDist = endX - marginNeeded;
              const rightDist = canvas.width - endX - marginNeeded;
              const topDist = endY - marginNeeded;
              const bottomDist = canvas.height - endY - marginNeeded;
              
              if (leftDist < 0) maxExtent = Math.max(maxExtent, -leftDist);
              if (rightDist < 0) maxExtent = Math.max(maxExtent, -rightDist);
              if (topDist < 0) maxExtent = Math.max(maxExtent, -topDist);
              if (bottomDist < 0) maxExtent = Math.max(maxExtent, -bottomDist);
            });
            
            if (maxExtent > 0) {
              // Kicsinyítési faktor számítása
              const availableSize = Math.min(canvas.width, canvas.height) - 2*margin;
              scaleFactor = availableSize / (availableSize + maxExtent * 2);
              
              // Újraszámoljuk a pontokat kisebb sugárral
              const newR = r * scaleFactor;
              pts.length = 0;
              for (let i = 0; i < L; i++) {
                pts.push({ 
                  x: cx + newR*Math.cos(2*Math.PI*i/L + angleOffset), 
                  y: cy + newR*Math.sin(2*Math.PI*i/L + angleOffset) 
                });
              }
            }
          }
        } else {
          const startX = margin;
          const startY = canvas.height/2;
          const dx = (canvas.width - 2*margin) / (maxL - 1);
          const amp = canvas.height * 0.08;
          for (let i = 0; i < L; i++) {
            pts.push({ x: startX + dx*i, y: startY + (i%2 ? amp : -amp) });
          }
        }

        ctx.lineWidth = Math.max(2, canvas.width * 0.003); 
        ctx.strokeStyle = '#000'; 
        ctx.fillStyle = '#000';
        const doubleBondOffset = Math.max(3, canvas.width * 0.006);
        const finalBranchLen = branchLen * scaleFactor;
        
        // Rajzoljuk meg először az összes kötést
        for (let i = 0; i < pts.length; i++) {
          const p = pts[i];
          const nextIdx = isCyclic ? (i+1) % pts.length : i+1;
          const next = pts[nextIdx];
          
          if (next) {
            const bondNum = i + 1;
            const isDoubleBond = dbPos.includes(bondNum);
            
            if (isDoubleBond) {
              const ang = Math.atan2(next.y - p.y, next.x - p.x);
              [1, -1].forEach(sign => {
                ctx.beginPath();
                ctx.moveTo(p.x + sign * Math.sin(ang) * doubleBondOffset, p.y - sign * Math.cos(ang) * doubleBondOffset);
                ctx.lineTo(next.x + sign * Math.sin(ang) * doubleBondOffset, next.y - sign * Math.cos(ang) * doubleBondOffset);
                ctx.stroke();
              });
            } else {
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(next.x, next.y);
              ctx.stroke();
            }
          }
        }
        
        // Rajzoljuk meg a csomópontokat felülre
        pts.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, nodeRadius, 0, 2 * Math.PI);
          ctx.fill();
        });
        branches.forEach(b => {
          let prev = pts[b.pos-1];
          const ang = -Math.PI/2; // Mindig felfelé
          
          for (let j = 0; j < b.len; j++) {
            const nx = prev.x + Math.cos(ang)*finalBranchLen;
            const ny = prev.y + Math.sin(ang)*finalBranchLen;
            ctx.beginPath(); ctx.moveTo(prev.x,prev.y); ctx.lineTo(nx,ny); ctx.stroke();
            ctx.beginPath(); ctx.arc(nx,ny,nodeRadius,0,2*Math.PI); ctx.fill();
            prev = {x:nx,y:ny};
          }
        });
      }

      newBtn.addEventListener('click', () => {
        const lvl = +document.getElementById('difficulty').value;
        if (hasMolecule && !checkBtn.disabled) {
          stats[lvl].wrong++;
          updateStatsUI(lvl);
        }
        nameInput.value = '';
        resultDiv.textContent = '';
        hintDiv.style.display = 'none';
        checkBtn.disabled = false;
        hintBtn.disabled = false;
        hasMolecule = true;
        drawMolecule();
      });

      hintBtn.addEventListener('click', () => {
        hintDiv.innerHTML = currentExplanation + `<div class="answer">Helyes válasz: <strong>${currentName}</strong></div>`;
        hintDiv.style.display = 'block';
        const lvl = +document.getElementById('difficulty').value;
        if (hasMolecule) {
          stats[lvl].wrong++;
          updateStatsUI(lvl);
        }
        checkBtn.disabled = true;
        hintBtn.disabled = true;
      });

      checkBtn.addEventListener('click', () => {
        if (!hasMolecule) return;
        const lvl = +document.getElementById('difficulty').value;
        if (normalize(nameInput.value) === normalize(currentName)) {
          stats[lvl].correct++;
          resultDiv.textContent = 'Helyes! ' + currentName;
          resultDiv.className = 'success';
        } else {
          stats[lvl].wrong++;
          resultDiv.textContent = 'Nem helyes! (' + currentName + ')';
          resultDiv.className = 'error';
        }
        updateStatsUI(lvl);
        checkBtn.disabled = true;
        hintBtn.disabled = true;
      });

      checkBtn.disabled = false;
      hintBtn.disabled = false;
      for (let i = 1; i <= 4; i++) updateStatsUI(i);
    });
  </script>
</body>
</html>